[{"content":"Você certamente já se deparou com a necessidade de consumir um estado compartilhado entre vários componentes no React em lugares distintos de sua aplicação e certamente já ouviu falar sobre o Redux como uma ferramenta robusta de gerenciar o estado.\nEmbora muito utilizado e bem documentado, é inegável que muitas vezes sua utilização é um bocado verbosa, necessitando de muito boilerplate para conseguir atingir uma funcionalidade básica.\nNeste artigo iremos utilizar um gerenciador de estado leve, rápido e de fácil utilização chamado zustand para resolver um problema de gerenciamento de estado de uma aplicação e vamos analisar suas principais características e pontos fortes.\nPara abrir o projeto completo, acesse através do github ou clique no botão abaixo para abrir diretamente no stackblitz\nSetup Primeiramente, iremos criar uma nova aplicação react, neste tutorial utilizaremos o vite.\nnpm create vite@latest -- --template react-ts em seguida ele irá pedir por um nome e irá criar um diretório com o código fonte do seu projeto, agora basta realizar a instalação dos módulos:\ncd pasta-do-projeto npm i zustand Instalando Chakra UI Com o módulo do zustand instalado já estamos prontos para utilizar a biblioteca, porém, irei utilizar uma biblioteca de elementos de UI para agilizar na estilização da aplicação, o Chakra UI.\nnpm i @chakra-ui/react @emotion/react@^11 @emotion/styled@^11 framer-motion@^6 Modificando o arquivo: src/main.tsx\nimport React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom/client\u0026#34;; import App from \u0026#34;./App\u0026#34;; import { ChakraProvider } from \u0026#34;@chakra-ui/react\u0026#34;; ReactDOM.createRoot(document.getElementById(\u0026#34;root\u0026#34;) as HTMLElement).render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ChakraProvider\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ChakraProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, ); Excluindo arquivos desnecessários Agora, delete os arquivos:\nsrc/App.css; src/index.css; src/assets/react.svg. e em App.tsx apague todo o conteúdo, deixando uma estrutura básica de componente:\nimport React from \u0026#34;react\u0026#34;; export const App = () =\u0026gt; { return \u0026lt;div /\u0026gt;; }; export default App; Modificando script de inicialização Por padrão o vite sobe a aplicação de desenvolvimento em alguma porta aleatória e isso é muito chato para o desenvolvimento, portanto, no arquivo package.json iremos modificar a linha 7 para especificar uma porta padrão, neste caso utilizaremos a porta 3333.\n\u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite --port 3333\u0026#34;, ... }, Criando a base da aplicação Nossa aplicação de exemplo será simples, porém terá uma série de oportunidades de demonstrar como podemos utilizar o gerenciamento de estado do Zustand em ação.\nA aplicação será um fragmento de um E-commerce, contendo um componente para definir o endereço de entrega do destinatário e um outro componente para apresentar o endereço de entrega salvo.\nEles serão:\nsrc/components/AddressForm.tsx src/components/AddressSummary.tsx Código do AddressForm.tsx import { Button, FormControl, FormHelperText, FormLabel, Input, Select, VStack, } from \u0026#34;@chakra-ui/react\u0026#34;; import React, { useState } from \u0026#34;react\u0026#34;; const AddressForm: React.FC = () =\u0026gt; { const [uf, setUf] = useState(\u0026#34;\u0026#34;); const [address, setAddress] = useState(\u0026#34;\u0026#34;); const [complement, setComplement] = useState(\u0026#34;\u0026#34;); const handleSubmit: React.FormEventHandler\u0026lt;HTMLDivElement\u0026gt; = (event) =\u0026gt; { event.preventDefault(); alert(JSON.stringify({ uf, address, complement, })); }; return ( \u0026lt;VStack as={\u0026#34;form\u0026#34;} onSubmit={handleSubmit}\u0026gt; \u0026lt;FormControl\u0026gt; \u0026lt;FormLabel\u0026gt;Estado\u0026lt;/FormLabel\u0026gt; \u0026lt;Select value={uf} onChange={(e) =\u0026gt; setUf(e.target.value)} bg={\u0026#34;white\u0026#34;} placeholder=\u0026#34;Selecione sua Unidade Federativa\u0026#34; \u0026gt; \u0026lt;option value=\u0026#34;AC\u0026#34;\u0026gt;Acre\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;AL\u0026#34;\u0026gt;Alagoas\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;AP\u0026#34;\u0026gt;Amapá\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;AM\u0026#34;\u0026gt;Amazonas\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;BA\u0026#34;\u0026gt;Bahia\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;CE\u0026#34;\u0026gt;Ceará\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;DF\u0026#34;\u0026gt;Distrito Federal\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;ES\u0026#34;\u0026gt;Espírito Santo\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;GO\u0026#34;\u0026gt;Goiás\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;MA\u0026#34;\u0026gt;Maranhão\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;MT\u0026#34;\u0026gt;Mato Grosso\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;MS\u0026#34;\u0026gt;Mato Grosso do Sul\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;MG\u0026#34;\u0026gt;Minas Gerais\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;PA\u0026#34;\u0026gt;Pará\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;PB\u0026#34;\u0026gt;Paraíba\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;PR\u0026#34;\u0026gt;Paraná\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;PE\u0026#34;\u0026gt;Pernambuco\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;PI\u0026#34;\u0026gt;Piauí\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;RJ\u0026#34;\u0026gt;Rio de Janeiro\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;RN\u0026#34;\u0026gt;Rio Grande do Norte\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;RS\u0026#34;\u0026gt;Rio Grande do Sul\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;RO\u0026#34;\u0026gt;Rondônia\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;RR\u0026#34;\u0026gt;Roraima\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;SC\u0026#34;\u0026gt;Santa Catarina\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;SP\u0026#34;\u0026gt;São Paulo\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;SE\u0026#34;\u0026gt;Sergipe\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;TO\u0026#34;\u0026gt;Tocantins\u0026lt;/option\u0026gt; \u0026lt;/Select\u0026gt; \u0026lt;/FormControl\u0026gt; \u0026lt;FormControl\u0026gt; \u0026lt;FormLabel\u0026gt;Seu Endereço\u0026lt;/FormLabel\u0026gt; \u0026lt;Input value={address} onChange={(e) =\u0026gt; setAddress(e.target.value)} bg={\u0026#34;white\u0026#34;} type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;FormHelperText\u0026gt;Insira a rua e o número (se existente).\u0026lt;/FormHelperText\u0026gt; \u0026lt;/FormControl\u0026gt; \u0026lt;FormControl\u0026gt; \u0026lt;FormLabel\u0026gt;Complemento (opcional)\u0026lt;/FormLabel\u0026gt; \u0026lt;Input value={complement} onChange={(e) =\u0026gt; setComplement(e.target.value)} bg={\u0026#34;white\u0026#34;} type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;/FormControl\u0026gt; \u0026lt;Button disabled={address.length === 0 || uf.length === 0} alignSelf={\u0026#34;end\u0026#34;} colorScheme={\u0026#34;blue\u0026#34;} type=\u0026#34;submit\u0026#34; \u0026gt; Salvar \u0026lt;/Button\u0026gt; \u0026lt;/VStack\u0026gt; ); }; export default AddressForm; Código do AddressSummary.tsx import { Box, Text, VStack } from \u0026#34;@chakra-ui/react\u0026#34;; import React from \u0026#34;react\u0026#34;; const AddressSummary: React.FC = () =\u0026gt; { return ( \u0026lt;VStack spacing={\u0026#34;4\u0026#34;} alignItems={\u0026#34;start\u0026#34;}\u0026gt; \u0026lt;Text alignSelf={\u0026#34;center\u0026#34;}\u0026gt; Revise as informações abaixo antes de confirmar a compra \u0026lt;/Text\u0026gt; \u0026lt;Box\u0026gt; \u0026lt;Text fontWeight={\u0026#34;bold\u0026#34;}\u0026gt;Estado\u0026lt;/Text\u0026gt; \u0026lt;Text fontSize={\u0026#34;lg\u0026#34;}\u0026gt;SP\u0026lt;/Text\u0026gt; \u0026lt;/Box\u0026gt; \u0026lt;Box\u0026gt; \u0026lt;Text fontWeight={\u0026#34;bold\u0026#34;}\u0026gt;Endereço\u0026lt;/Text\u0026gt; \u0026lt;Text fontSize={\u0026#34;lg\u0026#34;}\u0026gt;Rua dos passarinhos, 89\u0026lt;/Text\u0026gt; \u0026lt;/Box\u0026gt; \u0026lt;Box\u0026gt; \u0026lt;Text fontWeight={\u0026#34;bold\u0026#34;}\u0026gt;Complemento\u0026lt;/Text\u0026gt; \u0026lt;Text fontSize={\u0026#34;lg\u0026#34;}\u0026gt;apto 104\u0026lt;/Text\u0026gt; \u0026lt;/Box\u0026gt; \u0026lt;/VStack\u0026gt; ); }; export default AddressSummary; src/App.tsx contendo os dois componentes:\nimport { Box, Container } from \u0026#34;@chakra-ui/react\u0026#34;; import AddressForm from \u0026#34;./components/AddressForm\u0026#34;; import AddressSummary from \u0026#34;./components/AddressSummary\u0026#34;; export const App = () =\u0026gt; { return ( \u0026lt;Container maxW={\u0026#34;container.lg\u0026#34;} py={\u0026#34;10\u0026#34;}\u0026gt; \u0026lt;Box p={4} rounded=\u0026#34;md\u0026#34; shadow={\u0026#34;base\u0026#34;} bg={\u0026#34;gray.50\u0026#34;}\u0026gt; \u0026lt;AddressForm /\u0026gt; \u0026lt;/Box\u0026gt; \u0026lt;Box mt={4} p={4} rounded=\u0026#34;md\u0026#34; shadow={\u0026#34;base\u0026#34;} bg={\u0026#34;gray.50\u0026#34;}\u0026gt; \u0026lt;AddressSummary /\u0026gt; \u0026lt;/Box\u0026gt; \u0026lt;/Container\u0026gt; ); }; export default App; Como resultado das implementações teremos a seguinte UI:\nCriando nosso store global Toda vez que criamos um estado no Zustand, por padrão este estado criado é global, ou seja, ele pode ser utilizado por toda a aplicação.\nO que é mais surpreendente, é que não é necessário encapsular nossos componentes dentro de um provider ou algo do tipo, basta somente consumir este estado global e pronto!\nVamos agora criar este nosso estado global de Address:\nPrimeiro, vamos definir a interface desse estado, nesta interface iremos definir quais são as propriedades e métodos deste objeto, as propriedades nos dirão quais os dados que podemos consumir e os métodos serão os responsáveis pela mutação destes dados. src/store/AddressStore.ts\n1 2 3 4 5 6 7 8 9 10 interface Address { uf: string; address: string; complement?: string; } export interface IAddressStore { address: Address | null; setAddress: (address: Address) =\u0026gt; void; } Agora, com a interface definida, vamos criar o objeto que representará nosso estado global, o store, que exportaremos no formato de um hook: 1 2 3 4 5 6 7 8 9 10 11 import create from \u0026#34;zustand\u0026#34;; // Código das interfaces (passo 1) export const useAddressStore = create\u0026lt;IAddressStore\u0026gt;(set =\u0026gt; ({ address: null, setAddress: (address) =\u0026gt; set({ address, }), })); Explicando o código acima A função create, importada da biblioteca zustand é resposável por criar o store em si, ela recebe um tipo genérico que define a estrutura do store, indispensável para obtermos o intellisense no editor de texto, no meu caso, o VSCode.\nEsta função recebe uma função anônima como argumento, que é composta por dois parâmetros: set e get, e retorna um objeto de resposta que será a estrutura do nosso store, o seu tipo é definido pela interface que passamos como tipo genérico na chamada da função create.\nO parâmetro set é utilizado para definir as mutações dentro do nosso store, sempre que nós quisermos alterar alguma propriedade do nosso store, utilizaremos o parâmetro set para fazê-lo, este parâmetro também é uma função, e esta função recebe como parâmetro um objeto que satisfaça a estrutura do nosso store, como por exemplo, um objeto do tipo Address.\nO parâmetro get é utilizado para recuperar uma propriedade do nosso store.\nConectando o store aos componentes Agora o próximo passo é utilizar o estado que criamos nos nossos componentes, primeiramente vamos conectar o componente AddressSumary.tsx ao store utilizando o hook que criamos.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import { Box, VStack, Text, Alert, AlertDescription, AlertIcon, AlertTitle } from \u0026#39;@chakra-ui/react\u0026#39;; import React from \u0026#39;react\u0026#39;; import { useAddressStore } from \u0026#39;../store/AddressStore\u0026#39;; const AddressSummary: React.FC = () =\u0026gt; { const address = useAddressStore(state =\u0026gt; state.address); return \u0026lt;VStack spacing={\u0026#39;4\u0026#39;} alignItems={\u0026#39;start\u0026#39;}\u0026gt; \u0026lt;Text alignSelf={\u0026#39;center\u0026#39;}\u0026gt;Revise as informações abaixo antes de confirmar a compra\u0026lt;/Text\u0026gt; { address ? \u0026lt;\u0026gt; \u0026lt;Box\u0026gt; \u0026lt;Text fontWeight={\u0026#39;bold\u0026#39;}\u0026gt;Estado\u0026lt;/Text\u0026gt; \u0026lt;Text fontSize={\u0026#39;lg\u0026#39;}\u0026gt;{address.uf}\u0026lt;/Text\u0026gt; \u0026lt;/Box\u0026gt; \u0026lt;Box\u0026gt; \u0026lt;Text fontWeight={\u0026#39;bold\u0026#39;}\u0026gt;Endereço\u0026lt;/Text\u0026gt; \u0026lt;Text fontSize={\u0026#39;lg\u0026#39;}\u0026gt;{address.address}\u0026lt;/Text\u0026gt; \u0026lt;/Box\u0026gt; \u0026lt;Box\u0026gt; \u0026lt;Text fontWeight={\u0026#39;bold\u0026#39;}\u0026gt;Complemento\u0026lt;/Text\u0026gt; \u0026lt;Text fontSize={\u0026#39;lg\u0026#39;}\u0026gt;{address.complement || \u0026#39;Sem complemento\u0026#39;}\u0026lt;/Text\u0026gt; \u0026lt;/Box\u0026gt; \u0026lt;/\u0026gt; : \u0026lt;Alert rounded={\u0026#39;md\u0026#39;} status=\u0026#39;error\u0026#39;\u0026gt; \u0026lt;AlertIcon /\u0026gt; \u0026lt;AlertTitle\u0026gt;Nenhum endereço cadastrado\u0026lt;/AlertTitle\u0026gt; \u0026lt;/Alert\u0026gt; } \u0026lt;/VStack\u0026gt;; } export default AddressSummary; Temos o a página de endereço conectada ao nosso store, como nosso store é inicializado com a propriedade address: null, neste primeiro momento teremos somente o componente de Alert:\nSalvando os dados do formulário no store Agora, precisamos conectar o componente de formulário no store, tendo os seguintes comportamentos:\nNo carregamento inicial do componente, os dados iniciais deverão ser carregados com o que está presente no store; Ao clicar em salvar, os dados presentes no formulário deverão ser salvos no store. implementando o primeiro comportamento: src/components/AddressForm.tsx 11 12 13 14 15 16 17 18 19 const addressStore = useAddressStore(store =\u0026gt; store.address); useEffect(() =\u0026gt; { if (addressStore) { setUf(addressStore.uf); setAddress(addressStore.address); setComplement(addressStore.complement ?? \u0026#39;\u0026#39;); } }, [addressStore]); Como podemos observar, estamos nos inscrevendo no store de address, especificamente na propriedade address e sincronizando com o nosso state da aplicação através do useEffect, desta forma, quando houver alguma mudança na propriedade address e somente na propriedade address do nosso store, os dados serão sincronizados (ocasionando uma renderização do componente).\nImplementando o segundo comportamento 19 20 21 22 23 24 25 26 27 28 const setAddressStore = useAddressStore(store =\u0026gt; store.setAddress); const handleSubmit: React.FormEventHandler\u0026lt;HTMLDivElement\u0026gt; = (event) =\u0026gt; { event.preventDefault(); setAddressStore({ uf, address, complement }) }; De forma semelhante à que fizemos na implementação do primeiro comportamento, agora, selecionamos a porção do store que possui a função setAddres e a chamamos na função handleSubmit, responsável por lidar com o evento de envio do formulário de endereço.\nAgora a nossa aplicação está com o comportamento esperado:\nPersistindo o estado da aplicação no LocalStorage Há porém um problema na nossa implementação, ao atualizar a página o estado da aplicação (que é mantido em memória) é apagado, nos levando a ter que preencher novamente o endereço, por sorte, a biblioteca Zustand possui os Middlewares, que são funcionalidades extras que podemos anexar ao nosso store criado, e um dos middlewares que vêm junto com a biblioteca é o Middleware de persistência, que iremos implementar agora.\nsrc/store/AddressStore.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import create from \u0026#34;zustand\u0026#34;; import { persist } from \u0026#34;zustand/middleware\u0026#34;; // Codigo das interfaces export const useAddressStore = create( persist\u0026lt;IAddressStore\u0026gt;(set =\u0026gt; ({ address: null, setAddress: (address) =\u0026gt; set({ address, }), }), { name: \u0026#39;address-store\u0026#39; } ) ); Para implementar o middleware de persistência é muito simples, basta importar o persist de dentro do módulo zustand/middleware e colocar tudo que ficava dentro do create para dentro da chamada desta função persist, colocar o tipo genérico que ficava em create em persist e enfim, adicionar um segundo parâmetro dentro da chamada à função persist que será a configuração deste middleware de persistência, neste caso colocarei apenas uma chave chamada name, identificando no localstorage que se trata do estado guardado correspondente ao store de address.\nConclusão Ainda tem bastante coisa para discutir dentro do tópico de zustand, contudo com o que vimos, é realmente muito simples implementar o zustand dentro das nossas aplicações React para obter um gerenciamento de estado global com poucas linhas de código.\nSem dúvidas, ainda tem bastante coisa que podemos discutir e explorar dentro dessa biblioteca fenomenal, podem esperar mais conteúdo sobre ela. Abraços!!\n","permalink":"https://blog.hypeit.tech/posts/zustand/","summary":"Você certamente já se deparou com a necessidade de consumir um estado compartilhado entre vários componentes no React em lugares distintos de sua aplicação e certamente já ouviu falar sobre o Redux como uma ferramenta robusta de gerenciar o estado.\nEmbora muito utilizado e bem documentado, é inegável que muitas vezes sua utilização é um bocado verbosa, necessitando de muito boilerplate para conseguir atingir uma funcionalidade básica.\nNeste artigo iremos utilizar um gerenciador de estado leve, rápido e de fácil utilização chamado zustand para resolver um problema de gerenciamento de estado de uma aplicação e vamos analisar suas principais características e pontos fortes.","title":"Gerenciando estado no React com Zustand"}]